<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Halloween WebXR AR Experience</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #fff;
      z-index: 1;
      font-family: Arial, sans-serif;
    }
    #ar-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      background-color: #ff5722;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      z-index: 1;
    }
    #ar-button:hover {
      background-color: #e64a19;
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>ðŸŽƒ Halloween AR Experience ðŸ‘»</h1>
    <p>Tap the screen to place spooky objects in your environment!</p>
  </div>
  <button id="ar-button">Enter AR</button>

  <!-- Three.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <!-- Three.js ARButton -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/webxr/ARButton.js"></script>
  <!-- Three.js GLTFLoader for loading models -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"></script>

  <script>
    // Basic Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Add AR Button
    const arButton = document.getElementById('ar-button');
    arButton.addEventListener('click', () => {
      navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test']
      }).then(onSessionStarted);
    });

    function onSessionStarted(session) {
      renderer.xr.setSession(session);
      document.getElementById('ar-button').style.display = 'none';
    }

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    // Create a reticle for visual feedback
    const reticleGeometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
    const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Hit Test Source and Reference Space
    let hitTestSource = null;
    let localReferenceSpace = null;
    let latestFrame = null;

    renderer.xr.addEventListener('sessionstart', () => {
      const session = renderer.xr.getSession();

      session.requestReferenceSpace('viewer').then((refSpace) => {
        session.requestHitTestSource({ space: refSpace }).then((source) => {
          hitTestSource = source;
        });
      });

      localReferenceSpace = renderer.xr.getReferenceSpace();
    });

    renderer.xr.addEventListener('sessionend', () => {
      hitTestSource = null;
      reticle.visible = false;
    });

    // Load Halloween Models
    const loader = new THREE.GLTFLoader();

    // Array to store placed objects
    const placedObjects = [];

    // Function to add a pumpkin at a given position
    function addPumpkin(position) {
      console.log('Adding pumpkin at position:', position);
      loader.load(
        'https://github.com/laithi/arjstest/blob/main/future%20museum.gltf', // Correct raw URL
        function (gltf) {
          console.log('Pumpkin model loaded successfully');
          const pumpkin = gltf.scene;
          pumpkin.scale.set(0.5, 0.5, 0.5);
          pumpkin.position.copy(position);
          scene.add(pumpkin);
          placedObjects.push(pumpkin);
        },
        undefined,
        function (error) {
          console.error('An error happened while loading the pumpkin model.', error);
        }
      );
    }

    // Function to add a ghost at a given position
    function addGhost(position) {
      console.log('Adding ghost at position:', position);
      loader.load(
        'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Ghost/glTF/Ghost.gltf', // Example ghost model URL
        function (gltf) {
          console.log('Ghost model loaded successfully');
          const ghost = gltf.scene;
          ghost.scale.set(0.3, 0.3, 0.3);
          ghost.position.copy(position);
          scene.add(ghost);
          placedObjects.push(ghost);
        },
        undefined,
        function (error) {
          console.error('An error happened while loading the ghost model.', error);
        }
      );
    }

    // Handle touch/click to place objects
    window.addEventListener('touchend', onTouchEnd, false);
    window.addEventListener('click', onTouchEnd, false);

    function onTouchEnd(event) {
      console.log('Touch or Click detected');
      if (!hitTestSource || !latestFrame) {
        console.log('Hit test source or latest frame not available');
        return;
      }

      // Get touch position
      let touch = event.changedTouches ? event.changedTouches[0] : null;
      let x = 0;
      let y = 0;

      if (touch) {
        x = (touch.clientX / window.innerWidth) * 2 - 1;
        y = -(touch.clientY / window.innerHeight) * 2 + 1;
      }

      const frame = latestFrame;
      const referenceSpace = localReferenceSpace;

      const hitTestResults = frame.getHitTestResults(hitTestSource);
      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        const hitPose = hit.getPose(referenceSpace);

        const position = new THREE.Vector3().fromArray(hitPose.transform.position);

        console.log('Hit test successful, placing object at:', position);

        // Randomly decide to place a pumpkin or a ghost
        if (Math.random() > 0.5) {
          addPumpkin(position);
        } else {
          addGhost(position);
        }
      } else {
        console.log('No hit test results');
      }
    }

    // Animation Loop
    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      latestFrame = frame; // Store the latest frame for hit testing

      if (hitTestSource && frame) {
        const referenceSpace = localReferenceSpace;
        const hitTestResults = frame.getHitTestResults(hitTestSource);

        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const hitPose = hit.getPose(referenceSpace);

          reticle.visible = true;
          reticle.matrix.fromArray(hitPose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }

      renderer.render(scene, camera);
    }

    animate();

    // Handle Window Resize
    window.addEventListener('resize', onWindowResize, false);

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
